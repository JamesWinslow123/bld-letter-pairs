<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3BLD Letter Pair Trainer</title>
    
    <!-- FAVICON: Embedded SVG of a 3D-style blue cube -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3C!-- Main Blue Face --%3E%3Cpolygon points='10 20 90 20 90 80 10 80' fill='%2306B6D4'/%3E%3C!-- Left Shadow --%3E%3Cpolygon points='10 20 40 5 40 65 10 80' fill='%230891B2'/%3E%3C!-- Top Highlight --%3E%3Cpolygon points='10 20 90 20 60 5 40 5' fill='%2322D3EE'/%3E%3C!-- Letter B for BLD --%3E%3Ctext x='50' y='65' font-size='50' font-family='sans-serif' fill='white' text-anchor='middle' font-weight='bold'%3EB%3C/text%3E%3C/svg%3E">
    
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Inter font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;900&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            /* Added a subtle pattern for visual interest */
            background-color: #111827; /* bg-gray-900 */
            background-image: radial-gradient(#374151 0.5px, transparent 0.5px);
            background-size: 15px 15px;
        }

        /* Set base text color */
        body {
            color: #f3f4f6; /* text-gray-100 */
        }
        
        /* Custom styles for the 3D flip card */
        .card-container {
            perspective: 1000px;
        }

        .card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            transition: transform 0.6s; /* CSS Transition time to match JS timeout */
            transform-style: preserve-3d;
        }

        .card-container.is-flipped .card-inner {
            transform: rotateY(180deg);
        }

        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            border-radius: 0.5rem; /* rounded-lg */
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            text-align: center; 
        }

        .card-front {
            background-color: #1f2937; /* bg-gray-800 */
            border: 1px solid #374151; /* border-gray-700 */
        }

        .card-back {
            background-color: #374151; /* bg-gray-700 */
            border: 1px solid #4b5563; /* border-gray-600 */
            transform: rotateY(180deg);
        }

        /* Style for the custom select dropdown */
        .custom-select {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%239ca3af' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
            background-position: right 0.5rem center;
            background-repeat: no-repeat;
            background-size: 1.5em 1.5em;
            padding-right: 2.5rem;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }

        /* Style for disabled buttons */
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        button:disabled:hover {
            transform: none;
            /* Re-state base color to override hover */
            background-color: revert; 
        }
        #btn-show-answer:disabled:hover {
            background-color: #3b82f6; /* bg-blue-600 */
        }
        #btn-correct:disabled:hover {
            background-color: #16a34a; /* bg-green-600 */
        }
        #btn-incorrect:disabled:hover {
            background-color: #dc2626; /* bg-red-600 */
        }

        /* Styling for the file input */
        #file-upload::file-selector-button {
            cursor: pointer;
        }

    </style>
</head>
<body class="bg-gray-900 min-h-screen p-4 sm:p-8">

    <div class="max-w-2xl mx-auto">
        <!-- Header -->
        <h1 class="text-3xl sm:text-4xl font-bold text-center text-cyan-400 mb-6">
            3BLD Letter Pair Trainer
        </h1>

        <!-- Mode Switcher -->
        <div class="flex justify-center gap-4 mb-6">
            <button id="btn-train-mode" class="py-2 px-6 rounded-lg font-semibold transition-colors">
                Train
            </button>
            <button id="btn-edit-mode" class="py-2 px-6 rounded-lg font-semibold transition-colors">
                Edit
            </button>
        </div>

        <!-- Main Content Area -->
        <div id="app-content">

            <!-- Train Mode View -->
            <div id="train-view">
                <!-- Session Stats -->
                <div class="flex justify-around mb-4 text-lg bg-gray-800/50 backdrop-blur-sm p-4 rounded-lg shadow-md">
                    <div class="text-center">
                        <span class="text-gray-400 text-sm">CORRECT</span>
                        <div id="correct-count" class="text-3xl font-bold text-green-400">0</div>
                    </div>
                    <div class="text-center">
                        <span class="text-gray-400 text-sm">INCORRECT</span>
                        <div id="incorrect-count" class="text-3xl font-bold text-red-400">0</div>
                    </div>
                </div>

                <!-- Training Filter Selector -->
                <div class="mb-4">
                    <label for="train-letter-filter" class="block text-sm font-medium text-gray-400 mb-2">Focus Letter (First Letter of Pair):</label>
                    <select id="train-letter-filter" class="custom-select block w-full bg-gray-700 border border-gray-600 text-white rounded-md p-2 focus:ring-cyan-500 focus:border-cyan-500">
                        <!-- Options populated by JS -->
                    </select>
                </div>

                <!-- Flashcard -->
                <div id="card-container" class="card-container w-full h-52 sm:h-64">
                    <div id="card-inner" class="card-inner">
                        <!-- Front of Card (Letter Pair) -->
                        <div class="card-face card-front">
                            <span id="letter-pair" class="text-6xl sm:text-8xl font-black font-mono text-cyan-300"></span>
                        </div>
                        <!-- Back of Card (Mnemonic) -->
                        <div class="card-face card-back">
                            <span id="mnemonic-text" class="text-3xl sm:text-4xl font-semibold text-center"></span>
                        </div>
                    </div>
                </div>

                <!-- Train Controls -->
                <div class="mt-6 grid grid-cols-2 gap-4">
                    <button id="btn-show-answer" class="col-span-2 py-3 px-6 rounded-lg text-white font-semibold shadow-md transition-transform transform hover:scale-105 bg-blue-600 hover:bg-blue-500 disabled:bg-blue-600">
                        Show Mnemonic
                    </button>
                    <button id="btn-correct" class="py-3 px-6 rounded-lg text-white font-semibold shadow-md transition-transform transform hover:scale-105 bg-green-600 hover:bg-green-500 disabled:bg-green-600">
                        Correct
                    </button>
                    <button id="btn-incorrect" class="py-3 px-6 rounded-lg text-white font-semibold shadow-md transition-transform transform hover:scale-105 bg-red-600 hover:bg-red-500 disabled:bg-red-600">
                        Incorrect
                    </button>
                </div>
            </div>

            <!-- Edit Mode View (Hidden by default) -->
            <div id="edit-view" class="hidden">
                <div class="bg-gray-800 p-4 sm:p-6 rounded-lg shadow-xl">
                    <h2 class="text-xl font-semibold mb-4 text-gray-200">Edit Your Mnemonics</h2>
                    
                    <!-- Letter Selector -->
                    <div class="mb-4">
                        <label for="letter-select" class="block text-sm font-medium text-gray-400 mb-2">Select First Letter (A-X):</label>
                        <select id="letter-select" class="custom-select block w-full bg-gray-700 border border-gray-600 text-white rounded-md p-2 focus:ring-cyan-500 focus:border-cyan-500">
                            <!-- Options will be generated by JS -->
                        </select>
                    </div>

                    <!-- Mnemonic Input List -->
                    <div id="mnemonic-list" class="space-y-3 max-h-96 overflow-y-auto pr-2">
                        <!-- Inputs will be generated by JS -->
                    </div>

                    <!-- Save Button -->
                    <button id="btn-save" class="mt-6 w-full py-3 px-6 rounded-lg text-white font-semibold shadow-md transition-transform transform hover:scale-105 bg-cyan-600 hover:bg-cyan-500">
                        Save Mnemonics for this letter
                    </button>
                    <div id="save-feedback" class="text-center text-green-400 mt-2 h-4"></div>

                    <!-- Import/Export Section -->
                    <div class="mt-6 border-t border-gray-700 pt-6">
                        <h3 class="text-lg font-semibold mb-3 text-gray-300">Import / Export</h3>

                        <!-- Export -->
                        <button id="btn-export" class="w-full py-2 px-4 rounded-lg text-white font-semibold transition-colors bg-teal-600 hover:bg-teal-500 mb-4 shadow-md transition-transform transform hover:scale-[1.02]">
                            Export Mnemonics to TXT
                        </button>

                        <!-- Import -->
                        <label class="block text-sm font-medium text-gray-400 mb-2" for="file-upload">Import from TXT (Replaces all existing data):</label>
                        <div class="flex flex-col sm:flex-row gap-2 items-start">
                            <input type="file" id="file-upload" accept=".txt" class="flex-1 block w-full text-sm text-gray-400
                                file:mr-4 file:py-2 file:px-4 file:cursor-pointer
                                file:rounded-full file:border-0
                                file:text-sm file:font-semibold
                                file:bg-gray-700 file:text-cyan-400
                                hover:file:bg-gray-600
                            "/>
                            <button id="btn-import" class="w-full sm:w-auto py-2 px-4 rounded-lg text-white font-semibold transition-colors bg-purple-600 hover:bg-purple-500 disabled:opacity-50 shadow-md" disabled>
                                Import
                            </button>
                        </div>
                        <div id="import-feedback" class="text-center text-yellow-400 mt-2 h-4"></div>
                    </div>

                </div>
            </div>

        </div> <!-- /#app-content -->
    </div> <!-- /max-w-2xl -->

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- STATE ---
            const state = {
                currentMode: 'train', // 'train' or 'edit'
                mnemonics: {},      // Stores all user-defined pairs, e.g., {"AB": "Abacus"}
                allPairs: [],       // Array of all "XX" pairs, e.g., ["AA", "AB", ...]
                letters: "ABCDEFGHIJKLMNOPQRSTUVWX".split(''),
                currentCard: { pair: '', mnemonic: '' },
                isCardFlipped: false,
                editLetter: 'A',
                sessionStats: { correct: 0, incorrect: 0 },
                
                // NEW: Deck Management for fair, sequential practice
                shuffledDeck: [],   // The array of pairs in the current random order
                deckIndex: 0,       // Current position in the shuffledDeck
                lastPair: null,     // Stores the last pair shown to prevent immediate repetition across deck transitions
                
                trainFilterLetter: 'ALL', // Default to practice all letters
            };

            // --- CONSTANTS ---
            const MNEMONICS_KEY = 'bldMnemonics';
            const FLIP_DURATION_MS = 600; // Must match CSS transition duration

            // --- DOM ELEMENTS ---
            const btnTrainMode = document.getElementById('btn-train-mode');
            const btnEditMode = document.getElementById('btn-edit-mode');
            const trainView = document.getElementById('train-view');
            const editView = document.getElementById('edit-view');
            const letterPairText = document.getElementById('letter-pair');
            const mnemonicText = document.getElementById('mnemonic-text');
            const cardContainer = document.getElementById('card-container');
            const btnShowAnswer = document.getElementById('btn-show-answer');
            const btnCorrect = document.getElementById('btn-correct');
            const btnIncorrect = document.getElementById('btn-incorrect');
            const correctCount = document.getElementById('correct-count');
            const incorrectCount = document.getElementById('incorrect-count');
            const letterSelect = document.getElementById('letter-select');
            const mnemonicList = document.getElementById('mnemonic-list');
            const btnSave = document.getElementById('btn-save');
            const saveFeedback = document.getElementById('save-feedback');
            const trainLetterFilter = document.getElementById('train-letter-filter'); 

            // NEW Import/Export Elements
            const btnExport = document.getElementById('btn-export');
            const fileUpload = document.getElementById('file-upload');
            const btnImport = document.getElementById('btn-import');
            const importFeedback = document.getElementById('import-feedback');

            // --- DECK UTILITY ---
            /**
             * Shuffles an array in place using the Fisher-Yates (Knuth) algorithm.
             * @param {Array} array 
             * @returns {Array} The shuffled array.
             */
            function shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }

            /**
             * Generates and shuffles a new deck based on the current filter settings.
             */
            function generateShuffledDeck() {
                // 1. Determine base pairs (only saved ones)
                let filteredPairs = Object.keys(state.mnemonics);

                // 2. Apply filter
                if (state.trainFilterLetter !== 'ALL') {
                    filteredPairs = filteredPairs.filter(pair => pair.startsWith(state.trainFilterLetter));
                }

                if (filteredPairs.length === 0) {
                    state.shuffledDeck = [];
                    state.deckIndex = 0;
                    return;
                }
                
                // 3. Shuffle the array (using a copy to avoid mutating the original keys)
                let newDeck = shuffleArray([...filteredPairs]); 
                
                // 4. Repetition Check for Deck Transition (if deck length > 1)
                // Prevents the first card of the new deck from being the same as the last card of the previous deck.
                if (newDeck.length > 1 && state.lastPair && newDeck[0] === state.lastPair) {
                    // Swap the first card with a random card (other than the first)
                    const swapIndex = 1 + Math.floor(Math.random() * (newDeck.length - 1));
                    [newDeck[0], newDeck[swapIndex]] = [newDeck[swapIndex], newDeck[0]];
                }

                state.shuffledDeck = newDeck;
                state.deckIndex = 0;
            }


            // --- FUNCTIONS ---

            /**
             * Initializes the application
             */
            function init() {
                // 1. Generate all 576 letter pairs (A-X)
                for (const l1 of state.letters) {
                    for (const l2 of state.letters) {
                        state.allPairs.push(l1 + l2);
                    }
                }

                // 2. Load mnemonics from localStorage
                loadMnemonics();
                
                // 3. Initialize the first shuffled deck
                generateShuffledDeck();

                // 4. Populate Edit Mode dropdown and Train Filter dropdown
                populateLetterSelect();
                populateTrainFilterSelect(); 

                // 5. Set up initial UI
                updateModeUI();
                renderEditList();
                getNextCard();

                // 6. Attach event listeners
                btnTrainMode.addEventListener('click', () => switchMode('train'));
                btnEditMode.addEventListener('click', () => switchMode('edit'));
                btnShowAnswer.addEventListener('click', flipCard);
                btnCorrect.addEventListener('click', () => handleScore(true));
                btnIncorrect.addEventListener('click', () => handleScore(false));
                letterSelect.addEventListener('change', handleLetterSelectChange);
                trainLetterFilter.addEventListener('change', handleTrainFilterChange); 
                btnSave.addEventListener('click', saveCurrentLetterMnemonics);
                cardContainer.addEventListener('click', flipCard);
                
                // Import/Export Listeners
                btnExport.addEventListener('click', exportMnemonics);
                fileUpload.addEventListener('change', () => {
                    // Enable import button only if a file is selected
                    btnImport.disabled = fileUpload.files.length === 0;
                });
                btnImport.addEventListener('click', handleImport);
            }

            /**
             * Switches the view between 'train' and 'edit'
             */
            function switchMode(mode) {
                state.currentMode = mode;
                updateModeUI();
            }

            /**
             * Updates the UI to show/hide views based on the current mode
             */
            function updateModeUI() {
                if (state.currentMode === 'train') {
                    trainView.style.display = 'block';
                    editView.style.display = 'none';
                    btnTrainMode.classList.add('bg-cyan-600', 'text-white');
                    btnTrainMode.classList.remove('bg-gray-700', 'text-gray-300', 'hover:bg-gray-600');
                    btnEditMode.classList.add('bg-gray-700', 'text-gray-300', 'hover:bg-gray-600');
                    btnEditMode.classList.remove('bg-cyan-600', 'text-white');
                    
                    // Always try to load the next card when entering train mode
                    // This will generate a deck if necessary.
                    getNextCard(); 

                } else {
                    trainView.style.display = 'none';
                    editView.style.display = 'block';
                    btnTrainMode.classList.add('bg-gray-700', 'text-gray-300', 'hover:bg-gray-600');
                    btnTrainMode.classList.remove('bg-cyan-600', 'text-white');
                    btnEditMode.classList.add('bg-cyan-600', 'text-white');
                    btnEditMode.classList.remove('bg-gray-700', 'text-gray-300', 'hover:bg-gray-600');
                }
            }

            /**
             * Populates the letter select dropdown in Edit mode
             */
            function populateLetterSelect() {
                state.letters.forEach(letter => {
                    const option = document.createElement('option');
                    option.value = letter;
                    option.textContent = letter;
                    letterSelect.appendChild(option);
                });
                letterSelect.value = state.editLetter;
            }

            /**
             * Populates the letter select dropdown in Train mode for filtering
             */
            function populateTrainFilterSelect() {
                // Add 'ALL' option first
                const allOption = document.createElement('option');
                allOption.value = 'ALL';
                allOption.textContent = 'All'; // Simplified text
                trainLetterFilter.appendChild(allOption);
                
                // Add individual letter options (A-X)
                state.letters.forEach(letter => {
                    const option = document.createElement('option');
                    option.value = letter;
                    option.textContent = letter; // Simplified text
                    trainLetterFilter.appendChild(option);
                });
                trainLetterFilter.value = state.trainFilterLetter;
            }

            /**
             * Handles the 'change' event on the train filter dropdown
             */
            function handleTrainFilterChange(e) {
                state.trainFilterLetter = e.target.value;
                // Generate a new deck immediately upon filter change
                generateShuffledDeck(); 
                getNextCard();
            }

            /**
             * Renders the list of 24 input fields for the currently selected edit letter
             */
            function renderEditList() {
                mnemonicList.innerHTML = ''; // Clear existing list
                const pairsForLetter = state.allPairs.filter(p => p.startsWith(state.editLetter));

                pairsForLetter.forEach(pair => {
                    const savedMnemonic = state.mnemonics[pair] || '';
                    const row = document.createElement('div');
                    row.className = 'flex items-center gap-4';
                    
                    row.innerHTML = `
                        <label for="pair-${pair}" class="w-1/6 flex-shrink-0 font-mono text-xl text-gray-300">${pair}</label>
                        <input type="text" id="pair-${pair}" data-pair="${pair}" value="${savedMnemonic}" class="mnemonic-input flex-1 bg-gray-700 border border-gray-600 text-white rounded-md p-2 focus:ring-cyan-500 focus:border-cyan-500" placeholder="Your image/word...">
                    `;
                    mnemonicList.appendChild(row);
                });
            }

            /**
             * Handles the 'change' event on the letter select dropdown
             */
            function handleLetterSelectChange(e) {
                state.editLetter = e.target.value;
                btnSave.textContent = `Save Mnemonics for "${state.editLetter}"`;
                renderEditList();
            }

            /**
             * Saves the 24 mnemonics for the current edit letter
             */
            function saveCurrentLetterMnemonics() {
                const inputs = mnemonicList.querySelectorAll('.mnemonic-input');
                inputs.forEach(input => {
                    const pair = input.dataset.pair;
                    const value = input.value.trim();
                    if (value) {
                        state.mnemonics[pair] = value;
                    } else {
                        // If user clears an input, remove it from the object
                        delete state.mnemonics[pair];
                    }
                });

                // Save the entire mnemonics object to localStorage
                localStorage.setItem(MNEMONICS_KEY, JSON.stringify(state.mnemonics));

                // Show feedback
                saveFeedback.textContent = 'Saved!';
                setTimeout(() => {
                    saveFeedback.textContent = '';
                }, 2000);
            }

            /**
             * Loads all mnemonics from localStorage into the state
             */
            function loadMnemonics() {
                const savedData = localStorage.getItem(MNEMONICS_KEY);
                if (savedData) {
                    state.mnemonics = JSON.parse(savedData);
                } else {
                    state.mnemonics = {};
                }
            }

            /**
             * Gets the next card from the shuffled deck and updates the training UI.
             */
            function getNextCard() {
                // 1. Check if the deck is empty or exhausted
                if (state.shuffledDeck.length === 0 || state.deckIndex >= state.shuffledDeck.length) {
                    
                    // If no mnemonics are saved at all, show the setup message
                    if (Object.keys(state.mnemonics).length === 0) {
                        state.currentCard = { pair: '👋', mnemonic: "Add mnemonics in the 'Edit' tab to start training!" };
                        btnShowAnswer.disabled = true;
                        btnCorrect.disabled = true;
                        btnIncorrect.disabled = true;
                        state.lastPair = null; 
                        state.isCardFlipped = false;
                        renderCard();
                        return;
                    }
                    
                    // Generate a new deck if we ran out or if this is the first time loading
                    generateShuffledDeck();

                    // If after generation, the deck is still empty (due to filter), show message
                    if (state.shuffledDeck.length === 0) {
                        state.currentCard = { 
                            pair: 'Empty', 
                            mnemonic: `No mnemonics saved for pairs starting with ${state.trainFilterLetter}.` 
                        };
                        btnShowAnswer.disabled = true;
                        btnCorrect.disabled = true;
                        btnIncorrect.disabled = true;
                        state.lastPair = null; 
                        state.isCardFlipped = false;
                        renderCard();
                        return;
                    }
                }

                // 2. Retrieve the next card from the shuffled deck
                const randomPair = state.shuffledDeck[state.deckIndex];
                state.deckIndex++; // Increment index for the next call
                
                const mnemonic = state.mnemonics[randomPair]; 
                
                // 3. Update the state and UI
                state.currentCard = { pair: randomPair, mnemonic: mnemonic };
                state.isCardFlipped = false; // Always start a new card unflipped
                state.lastPair = randomPair; // Store the current pair as the last pair
                
                // Enable scoring buttons
                btnShowAnswer.disabled = false;
                btnCorrect.disabled = false;
                btnIncorrect.disabled = false;

                renderCard();
            }

            /**
             * Updates the card UI based on the current state
             */
            function renderCard() {
                letterPairText.textContent = state.currentCard.pair;
                mnemonicText.textContent = state.currentCard.mnemonic;
                
                // This controls the actual 3D rotation
                if (state.isCardFlipped) {
                    cardContainer.classList.add('is-flipped');
                    btnShowAnswer.textContent = 'Show Letter Pair';
                } else {
                    cardContainer.classList.remove('is-flipped');
                    btnShowAnswer.textContent = 'Show Mnemonic';
                }
            }

            /**
             * Toggles the card flip state
             */
            function flipCard() {
                // Don't flip if buttons are disabled (i.e., no cards)
                if(btnShowAnswer.disabled) return;
                
                state.isCardFlipped = !state.isCardFlipped;
                renderCard();
            }

            /**
             * Helper function to update stats and load the next card.
             * Used after the flip-back transition is complete.
             */
            function updateAndLoadNextCard() {
                getNextCard();
            }

            /**
             * Handles scoring a card (correct/incorrect) and manages the transition.
             */
            function handleScore(isCorrect) {
                // 1. Update session stats immediately
                if (isCorrect) {
                    state.sessionStats.correct++;
                } else {
                    state.sessionStats.incorrect++;
                }
                updateStatsUI();

                if (state.isCardFlipped) {
                    // Card is showing answer, need to unflip first, THEN load new content

                    // Step A: Immediately start the unflip transition (content remains old during rotation)
                    cardContainer.classList.remove('is-flipped');
                    
                    // Step B: Update the internal state and button text immediately
                    state.isCardFlipped = false;
                    btnShowAnswer.textContent = 'Show Mnemonic';
                    
                    // Step C: Wait for the 0.6s transition before loading the new content
                    setTimeout(updateAndLoadNextCard, FLIP_DURATION_MS);
                } else {
                    // If card is already showing the letter pair (user scored before checking answer), load new content immediately
                    updateAndLoadNextCard();
                }
            }

            /**
             * Updates the stats display
             */
            function updateStatsUI() {
                correctCount.textContent = state.sessionStats.correct;
                incorrectCount.textContent = state.sessionStats.incorrect;
            }

            /**
             * Exports all mnemonics to a downloadable .txt file.
             */
            function exportMnemonics() {
                // Format: PAIR: MNEMONIC (one per line)
                const textContent = Object.entries(state.mnemonics)
                    // Sort alphabetically by pair for clean file structure
                    .sort((a, b) => a[0].localeCompare(b[0])) 
                    .map(([pair, mnemonic]) => `${pair}: ${mnemonic}`)
                    .join('\n');

                const blob = new Blob([textContent], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = '3bld_mnemonics.txt';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            /**
             * Handles the import button click and reads the selected file.
             */
            function handleImport() {
                const file = fileUpload.files[0];
                if (file) {
                    importMnemonics(file);
                }
            }

            /**
             * Reads and parses the .txt file content to update mnemonics.
             * This function REPLACES all existing mnemonics.
             */
            function importMnemonics(file) {
                // Clear previous message immediately upon new attempt
                importFeedback.textContent = 'Importing...'; 
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    const text = e.target.result;
                    const lines = text.split('\n').map(line => line.trim()).filter(line => line.length > 0);
                    const newMnemonics = {};
                    let count = 0;
                    const validLetters = new Set(state.letters);

                    lines.forEach(line => {
                        // Split only on the first colon (:) to allow mnemonics to contain colons
                        const parts = line.split(/:\s*/, 2); 
                        if (parts.length === 2) {
                            const pair = parts[0].trim().toUpperCase();
                            const mnemonic = parts[1].trim();

                            // Basic validation: pair must be 2 letters from A-X
                            if (pair.length === 2 && 
                                validLetters.has(pair[0]) && 
                                validLetters.has(pair[1]) && 
                                mnemonic.length > 0) {
                                
                                newMnemonics[pair] = mnemonic;
                                count++;
                            }
                        }
                    });

                    if (count > 0) {
                        // Success path
                        state.mnemonics = newMnemonics;
                        localStorage.setItem(MNEMONICS_KEY, JSON.stringify(state.mnemonics));
                        
                        // Update UI and create a new shuffled deck
                        renderEditList(); 
                        generateShuffledDeck(); // Important: Regenerate the deck after importing new data
                        importFeedback.textContent = `✅ Successfully imported ${count} mnemonic pairs!`;
                        
                        // If we are in train mode, load the first card with new data
                        if (state.currentMode === 'train') getNextCard();
                        
                    } else {
                        // Error path (no valid pairs)
                        importFeedback.textContent = '❌ Error: No valid pairs found in file. Ensure format is PAIR: Mnemonic';
                    }

                    // Reset file input and button state
                    fileUpload.value = '';
                    btnImport.disabled = true;
                    // The error/success message persists until the next file upload attempt.
                };
                
                reader.onerror = () => {
                    // File reading error path
                    importFeedback.textContent = '❌ Error reading file.';
                    
                    // Reset file input and button state
                    fileUpload.value = '';
                    btnImport.disabled = true;
                };
                
                reader.readAsText(file);
            }

            // --- START THE APP ---
            init();
        });
    </script>

</body>
</html>
